<html lang="pt-BR">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="stylesheet" href="./css/geral.css" />
		<link rel="stylesheet" href="./css/header.css" />
		<link rel="stylesheet" href="./css/installation.css" />
		<link rel="stylesheet" href="./css/responsive.css" />
		<link rel="shurtcut icon" href="./images/ruby.png" />
		<title>Instalação</title>
	</head>
	<body>
		<header>
			<nav class="menu">
				<div class="logo">
					<img src="./images/ruby.png" width="20%" alt="logo" />
				</div>
				<button class="botao-menu" id="botao-menu">
					<img src="./images/botao.png" alt="botao" />
				</button>
				<button class="botao-menu" id="botao-fechar">
					<img src="./images/fechar.png" alt="botao fechar" />
				</button>
				<ul class="font-item" id="menu-mobile">
					<li>
						<a href="./index.html">Página Inicial</a>
					</li>
					<li>
						<a href="./installation.html">Instalação</a>
					</li>
					<li>
						<a href="./connectionArduino.html">Conexão com Arduino</a>
					</li>
					<li>
						<a href="connectionESP32.html">Conexão com ESP32</a>
					</li>
					<li>
						<a href="./examples.html">Exemplos</a>
					</li>
				</ul>
			</nav>
		</header>
		<main class="geral">
			<div class="inicio"></div>
			<section class="align-self-end">
				<div class="topic-1"></div>
				<div class="container">
					<h6 class="font-title margin-bottom-15">
						Exemplos de códigos para você executar e enviar para o arduino
					</h6>
					<p class="font-p3 margin-bottom-15">
						Fazer um led piscar:
					</p>
					<div class="requeriments margin-bottom-15">
						<p class="font-p3">require 'rubygems'</p>
						<p class="font-p3">require 'arduino_firmata'</p>
						<br />
						<p class="font-p3">
							arduino = ArduinoFirmata.connect "/dev/ttyUSB0"
						</p>
						<br />
						<p class="font-p3">
							#ACENDER E DESLIGAR O LED
						</p>
						<br />
						<p class="font-p3">
							arduino.pin_mode 2, ArduinoFirmata::OUTPUT
						</p>
						<p class="font-p3">
							stat = true
						</p>
						<p class="font-p3">
							loop do
						</p>
						<p class="font-p3">
							puts stat
						</p>
						<p class="font-p3">
							arduino.digital_write 10, stat
						</p>
						<p class="font-p3">
							stat = !stat
						</p>
						<p class="font-p3">
							sleep 1
						</p>
						<p class="font-p3">
							end
						</p>
					</div>
					<p class="font-p3">
						<strong>Explicação do código</strong>: Primeiramente, é importado a
						biblioteca 'rubygems' e 'arduino_firmata'. Após isso, é feito a
						conexão do arduino através da porta ttyUSB0. Logo em seguida é
						declarado que o pino 2 do arduino, irá ser um pino de saída. Então,
						uma variável state é declarada e inicializada para assumir o estado
						do led(HIGH or LOW). O programa entra no loop que fica trocando o
						estado do led a cada 1 segundo.
					</p>
				</div>
				<div class="topic-geral"></div>
				<div class="container">
					<p class="font-p3 margin-bottom-15">
						Acender um led pressionando um botão:
					</p>
					<div class="requeriments margin-bottom-15">
						<p class="font-p3">require 'rubygems'</p>
						<p class="font-p3">require 'arduino_firmata'</p>
						<br />
						<p class="font-p3">
							arduino = ArduinoFirmata.connect "/dev/ttyUSB0"
						</p>
						<br />
						<p class="font-p3">
							#ACENDER E DESLIGAR O LED COM BOTÃO
						</p>
						<br />
						<p class="font-p3">
							arduino.pin_mode 7, ArduinoFirmata::INPUT
						</p>
						<p class="font-p3">
							arduino.pin_mode 2, ArduinoFirmata::OUTPUT
						</p>
						<p class="font-p3">
							loop do
						</p>
						<p class="font-p3">
							if arduino.digital_read 7
						</p>
						<p class="font-p3">
							arduino.digital_write 2, true
						</p>
						<p class="font-p3">
							else
						</p>
						<p class="font-p3">
							arduino.digital_write 2, false
						</p>
						<p class="font-p3">
							end
						</p>
						<p class="font-p3">
							sleep 0.5
						</p>
						<p class="font-p3">
							end
						</p>
					</div>
					<p class="font-p3">
						<strong>Explicação do código</strong>: Primeiramente, é importado a
						biblioteca 'rubygems' e 'arduino_firmata'. Após isso, é feito a
						conexão do arduino através da porta ttyUSB0. Logo em seguida, é
						declarado que o pino 7 do arduino irá ser um pino de entrada e o
						pino 2 irá ser um de saída. Então o programa entra em um loop, onde
						a condição que testa se o botão foi apertado é verificada. Se ela
						retornar true, então o pino 2 é setado como true(HIGH), senão, ele
						fica setado como false(LOW).
					</p>
				</div>
				<div class="topic-geral"></div>
				<div class="container">
					<p class="font-p3 margin-bottom-15">
						Controlar o brilho do led através de um potenciômetro
					</p>
					<div class="requeriments margin-bottom-15">
						<p class="font-p3">require 'rubygems'</p>
						<p class="font-p3">require 'arduino_firmata'</p>
						<br />
						<p class="font-p3">
							arduino = ArduinoFirmata.connect "/dev/ttyUSB0"
						</p>
						<br />
						<p class="font-p3">
							#LIGAR O LED E AJUSTAR O SEU BRILHO COM O POTENCIÔMETRO
						</p>
						<br />
						<p class="font-p3">
							loop do
						</p>
						<p class="font-p3">
							an = arduino.analog_read 0 #Retorna entre 0 e 1023 (10bist)
						</p>
						<p class="font-p3">
							puts an
						</p>
						<p class="font-p3">
							arduino.analog_write 10, an/4 #Ajusta para a escala de 0 a 255
							(8bits) do pwm
						</p>
						<p class="font-p3">
							sleep 0.1
						</p>
						<p class="font-p3">
							end
						</p>
					</div>
					<p class="font-p3">
						<strong>Explicação do código</strong>: Primeiramente, é importado a
						biblioteca 'rubygems' e 'arduino_firmata'. Após isso, é feito a
						conexão do arduino através da porta ttyUSB0. Então o programa entra
						em um loop, onde uma variável que recebe o valor de acordo com a
						movimentação do eixo do potenciômetro é printada no terminal a cada
						0.1s. No pino 10, onde o led está ligado, é aceso o led com o valor
						ajustado para uma escala de 8 bits, visto que o valor recebido está
						em uma escala de 10 bits.
					</p>
				</div>
				<div class="topic-geral"></div>
				<div class="container">
					<h6 class="font-title margin-bottom-15">
						Exemplos de códigos para você executar e enviar para o ESP32
					</h6>
					<p class="font-p3 margin-bottom-15">
						Fazer um led piscar:
					</p>
					<div class="requeriments margin-bottom-15">
						<p class="font-p3">
							#!/usr/bin/env ruby
						</p>
						<p class="font-p3">
							$:.unshift File.expand_path '../../lib', File.dirname(__FILE__)
						</p>
						<p class="font-p3">require 'rubygems'</p>
						<p class="font-p3">require 'arduino_firmata'</p>
						<br />
						<p class="font-p3">
							arduino = ArduinoFirmata.connect "/dev/ttyUSB0"
						</p>
						<p class="font-p3">puts "firmata version #{arduino.version}"</p>
						<br />
						<p class="font-p3">
							#ACENDER E DESLIGAR O LED
						</p>
						<br />
						<p class="font-p3">
							## regist event
						</p>
						<p class="font-p3">
							arduino.on :sysex do |command, data|
						</p>
						<p class="font-p3">
							puts "command : #{command}"
						</p>
						<p class="font-p3">
							puts "data : #{data.inspect}"
						</p>
						<p class="font-p3">
							end
						</p>
						<p class="font-p3">
							## send sysex command
						</p>
						<p class="font-p3">
							arduino.sysex 0x01, [13, 5, 2] # pin13, blink 5 times, 200 msec
							interval
						</p>
						<p class="font-p3">
							arduino.sysex 0x01, [11, 3, 10] # pin11, blink 3 times, 1000 msec
							interval
						</p>
						<p class="font-p3">
							loop do
						</p>
						<p class="font-p3">
							sleep 1
						</p>
						<p class="font-p3">
							end
						</p>
					</div>
					<p class="font-p3">
						<strong>Explicação do código</strong>: Primeiramente, é importado a
						biblioteca 'rubygems' e 'arduino_firmata'. Após isso, é feito a
						conexão do arduino através da porta ttyUSB0. Logo em seguida é
						printado a versão do firmata. Em seguida, a rotina de listener da
						sysex é chamada para ficar monitorando e printando os comandos e os
						valores a ser passado para a sysex do StandardFirmataESP32 via a
						sysex do ruby. Então, os comandos são passados, definindo o case de
						tratamento do StandardFirmata para esta rotina sysex, o 0x01. Os
						comandos passados pelo parâmetro da primeira chamada sysex são o
						pino (13), quantas vezes vai ser piscado o led (5) e o tempo (2). Na
						segunda chamada sysex, são passados o pino (11), a quantidade de
						vezes que o led vai piscar (3) e o tempo (10). Esses parâmetros são
						tratados na sysexCallBack, no StandardFirmataESP32. Lá, ela recebe
						os parâmetros no argv em c++ e, dentro da função, ela realiza o
						tratamento da ação que será realizada com base nesses parâmetros
						recebidos através do ruby.
					</p>
				</div>
				<div class="topic-geral"></div>
				<div class="container">
					<p class="font-p3 margin-bottom-15">
						Leitura e escrita digital:
					</p>
					<div class="requeriments margin-bottom-15">
						<p class="font-p3">
							#!/usr/bin/env ruby
						</p>
						<p class="font-p3">
							$:.unshift File.expand_path '../../lib', File.dirname(__FILE__)
						</p>
						<p class="font-p3">require 'rubygems'</p>
						<p class="font-p3">require 'arduino_firmata'</p>
						<br />
						<p class="font-p3">
							arduino = ArduinoFirmata.connect "/dev/ttyUSB0"
						</p>
						<p class="font-p3">puts "firmata version #{arduino.version}"</p>
						<br />
						<p class="font-p3">
							## regist event
						</p>
						<br />
						<p class="font-p3">
							arduino.on :sysex do |command, data|
						</p>
						<p class="font-p3">
							if command == 0x02
						</p>
						<p class="font-p3">
							puts "command : #{command}"
						</p>
						<p class="font-p3">
							puts "data : #{data.inspect}"
						</p>
						<p class="font-p3">
							end
						</p>
						<p class="font-p3">
							end
						</p>
						<p class="font-p3">
							loop
						</p>
						<p class="font-p3">
							## send sysex command at the digital tratament case 0x02.
						</p>
						<p class="font-p3">
							arduino.sysex 0x02, [22, 23] #read at pin 22 and write at pin 23
						</p>
						<p class="font-p3">
							sleep 1
						</p>
						<p class="font-p3">
							end
						</p>
					</div>
					<p class="font-p3">
						<strong>Explicação do código</strong>: Primeiramente, é importado a
						biblioteca 'rubygems' e 'arduino_firmata'. Após isso, é feito a
						conexão do arduino através da porta ttyUSB0. Logo em seguida é
						printado a versão do firmata. Em seguida, a rotina de listener da
						sysex é chamada para ficar monitorando e printando os comandos e os
						valores a ser passado para a sysex do StandardFirmataESP32 via a
						sysex do ruby. Então, os comandos são passados, definindo o case de
						tratamento digital do StandardFirmata para esta rotina sysex, o
						0x02. Os comandos passados pelo parâmetro da primeira chamada sysex
						são o pino de leitura (22), o pino de escrita (23). Na função sysex
						do StandardFirmataESP32, esses pinos são setados e tratados com
						comandos DIRETO do arduino.
					</p>
				</div>
				<div class="topic-geral"></div>
				<div class="container">
					<p class="font-p3 margin-bottom-15">
						Leitura e escrita analógica:
					</p>
					<div class="requeriments margin-bottom-15">
						<p class="font-p3">
							#!/usr/bin/env ruby
						</p>
						<p class="font-p3">
							$:.unshift File.expand_path '../../lib', File.dirname(__FILE__)
						</p>
						<p class="font-p3">require 'rubygems'</p>
						<p class="font-p3">require 'arduino_firmata'</p>
						<br />
						<p class="font-p3">
							arduino = ArduinoFirmata.connect "/dev/ttyUSB0"
						</p>
						<p class="font-p3">puts "firmata version #{arduino.version}"</p>
						<br />
						<p class="font-p3">
							## regist event
						</p>
						<br />
						<p class="font-p3">
							arduino.on :sysex do |command, data|
						</p>
						<p class="font-p3">
							if command == 0x03
						</p>
						<p class="font-p3">
							puts "command : #{command}"
						</p>
						<p class="font-p3">
							puts "data : #{data.inspect}"
						</p>
						<p class="font-p3">
							end
						</p>
						<p class="font-p3">
							end
						</p>
						<p class="font-p3">
							loop
						</p>
						<p class="font-p3">
							## send sysex command at the analog tratament case 0x03.
						</p>
						<p class="font-p3">
							arduino.sysex 0x03, [32, 33] #read at pin 32 and write at pin 33
						</p>
						<p class="font-p3">
							sleep 1
						</p>
						<p class="font-p3">
							end
						</p>
					</div>
					<p class="font-p3">
						<strong>Explicação do código</strong>: Primeiramente, é importado a
						biblioteca 'rubygems' e 'arduino_firmata'. Após isso, é feito a
						conexão do arduino através da porta ttyUSB0. Logo em seguida é
						printado a versão do firmata. Em seguida, a rotina de listener da
						sysex é chamada para ficar monitorando e printando os comandos e os
						valores a ser passado para a sysex do StandardFirmataESP32 via a
						sysex do ruby. Então, os comandos são passados, definindo o case de
						tratamento analógico do StandardFirmata para esta rotina sysex, o
						0x03. Os comandos passados pelo parâmetro da primeira chamada sysex
						são o pino de leitura (32), o pino de escrita (33). Na função sysex
						do StandardFirmataESP32, esses pinos são setados e tratados com
						comandos DIRETO do arduino.
					</p>
				</div>
				<div class="topic-geral"></div>
				<div class="container">
					<p class="font-p3 margin-bottom-15">
						Leitura e escrita analógica em um canal específico:
					</p>
					<div class="requeriments margin-bottom-15">
						<p class="font-p3">
							#!/usr/bin/env ruby
						</p>
						<p class="font-p3">
							$:.unshift File.expand_path '../../lib', File.dirname(__FILE__)
						</p>
						<p class="font-p3">require 'rubygems'</p>
						<p class="font-p3">require 'arduino_firmata'</p>
						<br />
						<p class="font-p3">
							arduino = ArduinoFirmata.connect "/dev/ttyUSB0"
						</p>
						<p class="font-p3">puts "firmata version #{arduino.version}"</p>
						<br />
						<p class="font-p3">
							## regist event
						</p>
						<br />
						<p class="font-p3">
							arduino.on :sysex do |command, data|
						</p>
						<p class="font-p3">
							if command == 0x03
						</p>
						<p class="font-p3">
							puts "command : #{command}"
						</p>
						<p class="font-p3">
							puts "data : #{data.inspect}"
						</p>
						<p class="font-p3">
							end
						</p>
						<p class="font-p3">
							end
						</p>
						<p class="font-p3">
							loop
						</p>
						<p class="font-p3">
							## send sysex command at the analog tratament case 0x03.
						</p>
						<p class="font-p3">
							arduino.sysex 0x03, [32, 33, 1] #read at pin 32, write at pin 33
							and set channel 1
						</p>
						<p class="font-p3">
							sleep 1
						</p>
						<p class="font-p3">
							end
						</p>
					</div>
					<p class="font-p3">
						<strong>Explicação do código</strong>: Primeiramente, é importado a
						biblioteca 'rubygems' e 'arduino_firmata'. Após isso, é feito a
						conexão do arduino através da porta ttyUSB0. Logo em seguida é
						printado a versão do firmata. Em seguida, a rotina de listener da
						sysex é chamada para ficar monitorando e printando os comandos e os
						valores a ser passado para a sysex do StandardFirmataESP32 via a
						sysex do ruby. Então, os comandos são passados, definindo o case de
						tratamento analógico do StandardFirmata para esta rotina sysex, o
						0x03. Os comandos passados pelo parâmetro da primeira chamada sysex
						são o pino de leitura (32), o pino de escrita (33) e o canal (1). Na
						função sysex do StandardFirmataESP32, esses pinos são setados e
						tratados com comandos DIRETO do arduino.
					</p>
				</div>
				<div class="topic-geral"></div>
				<div class="container">
					<p class="font-title margin-bottom-15">
						Gostou desses exemplos?
					</p>
					<p class="font-p3">
						Se você gostou desses exemplos, com certeza vai gostar de saber o
						que esse framework é capaz de fazer. Visite o
						<a href="https://github.com/Gustavo053"
							>Github de Gustavo Pereira</a
						>
						para ter acesso a esses exemplos simples e todo o material de
						conexão e códigos com o <strong>ESP32</strong> e arduino, ou acesse
						o
						<a href="https://github.com/Gustavo053/arduino_firmata"
							>Github oficial</a
						>
						do framework para obter mais exemplos simples com o Arduino.
					</p>
				</div>
				<div class="topic-geral"></div>
			</section>
		</main>
	</body>
	<script src="./js/collapse.js"></script>
</html>
